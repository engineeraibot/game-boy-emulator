<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Game Boy</title>
    <style>
      :root {
        --btn-size: 60px;
        --btn-gap: 8px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100dvh;
        overflow-x: hidden;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #ffffff;
        font-family: "Segoe UI", Tahoma, sans-serif;
        color: #111111;
        user-select: none;
      }

      main {
        flex: 1;
        min-height: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        padding: 12px 16px;
      }

      canvas {
        width: min(100vw, 540px);
        max-width: 540px;
        max-height: 70vh;
        aspect-ratio: 160 / 144;
        height: auto;
        image-rendering: pixelated;
        background: #000;
        border-radius: 8px;
      }

      footer {
        width: 100%;
        padding: 12px 16px;
        background: #f5f5f5;
        padding-bottom: env(safe-area-inset-bottom, 12px);
      }

      .footer-inner {
        max-width: 1000px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
      }

      .rom-loader {
        width: 100%;
        display: flex;
        justify-content: center;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }

      .rom-button {
        border: 1px solid #d0d0d0;
        border-radius: 10px;
        background: linear-gradient(180deg, #fafafa, #e1e1e1);
        padding: 10px 16px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        color: #222222;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
        transition: transform 0.06s ease, box-shadow 0.06s ease;
      }

      .rom-button:active {
        transform: translateY(1px);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.12);
      }

      .rom-filename {
        font-size: 13px;
        color: #444444;
        max-width: 50vw;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .touch-controls {
        display: none;
        flex-wrap: wrap;
        gap: 20px;
        justify-content: center;
        width: 100%;
      }

      .dpad {
        display: grid;
        grid-template-areas:
          ". up ."
          "left center right"
          ". down .";
        grid-template-columns: repeat(3, var(--btn-size));
        grid-template-rows: repeat(3, var(--btn-size));
        gap: var(--btn-gap);
      }

      .dpad .up { grid-area: up; }
      .dpad .down { grid-area: down; }
      .dpad .left { grid-area: left; }
      .dpad .right { grid-area: right; }
      .dpad .spacer { grid-area: center; }

      .action-buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
      }

      .ab-buttons {
        display: flex;
        gap: 14px;
        align-items: center;
        justify-content: center;
      }

      .meta-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
      }

      .control-btn {
        border: 1px solid #d0d0d0;
        border-radius: 12px;
        background: linear-gradient(180deg, #fafafa, #dedede);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        min-width: var(--btn-size);
        min-height: var(--btn-size);
        font-size: 16px;
        font-weight: 600;
        color: #222222;
        cursor: pointer;
        touch-action: none;
        user-select: none;
        transition: transform 0.06s ease, box-shadow 0.06s ease;
      }

      .control-btn:active {
        transform: translateY(1px);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.12);
      }

      .small-btn {
        min-width: 86px;
        min-height: 38px;
        font-size: 14px;
        border-radius: 10px;
      }

      .footer-text {
        text-align: center;
        font-size: 14px;
        color: #444444;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      #legend {
        margin: 0;
      }

      #legend p {
        margin: 0;
        font-weight: 600;
      }

      footer p {
        margin: 0;
      }

      @media (max-width: 640px) {
        :root {
          --btn-size: clamp(44px, 12vw, 56px);
          --btn-gap: 5px;
        }

        main {
          padding: 8px 12px;
          align-items: flex-start;
          justify-content: center;
        }

        canvas {
          width: 100%;
          max-width: 100%;
          max-height: 48vh;
        }

        .touch-controls {
          gap: 10px;
          display: flex;
          flex-wrap: wrap;
          justify-content: center;
        }

        .keyboard-legend {
          display: none;
        }

        .small-btn {
          min-width: 72px;
          min-height: 34px;
          font-size: 13px;
        }

        footer {
          padding: 10px 12px;
          padding-bottom: env(safe-area-inset-bottom, 10px);
        }
      }

      @media (min-width: 641px) {
        canvas {
          max-height: 72vh;
          width: min(88vw, 620px);
        }

        .touch-controls {
          display: none;
        }
      }

      @media (max-height: 700px) {
        :root {
          --btn-size: clamp(40px, 11vw, 50px);
          --btn-gap: 4px;
        }

        canvas {
          max-height: 42vh;
        }

        .small-btn {
          min-width: 66px;
          min-height: 32px;
        }
      }

      @media (hover: none) and (pointer: coarse) {
        .touch-controls {
          display: flex;
        }

        .keyboard-legend {
          display: none;
        }
      }
    </style>
    <script type="text/javascript" src="joypad.js"></script>
    <script type="text/javascript" src="memorymanagementunit.js"></script>
    <script type="text/javascript" src="cpu.js"></script>
    <script type="text/javascript" src="pixelprocessingunit.js"></script>
    <script type="text/javascript" src="PulseChannel.js"></script>
    <script type="text/javascript" src="WaveChannel.js"></script>
    <script type="text/javascript" src="NoiseChannel.js"></script>
    <script id="apu-script" type="text/javascript" src="apu.js"></script>
  </head>
  <body>
    <main>
      <canvas id="screen" width="160" height="144"></canvas>
    </main>
    <footer>
      <div class="footer-inner">
        <div class="rom-loader">
          <input type="file" id="rom-input" accept=".gb,.gbc,application/octet-stream" style="display:none" aria-label="Select Game Boy ROM">
          <button type="button" id="rom-button" class="rom-button">Load ROM</button>
          <button type="button" id="save-state" class="rom-button">Save State</button>
          <input type="file" id="state-input" accept=".state,application/json" style="display:none" aria-label="Load saved state">
          <button type="button" id="load-state" class="rom-button">Load State</button>
          <button type="button" id="save-game" class="rom-button">Save Game</button>
          <input type="file" id="save-input" accept=".sav,application/octet-stream" style="display:none" aria-label="Load save game">
          <button type="button" id="load-game" class="rom-button">Load Game</button>
          <span id="rom-filename" class="rom-filename" aria-live="polite"></span>
        </div>
        <div class="touch-controls" aria-label="On-screen controls">
          <div class="dpad" aria-label="Directional pad">
            <button type="button" class="control-btn up" data-button="Up" aria-label="Up">Up</button>
            <button type="button" class="control-btn left" data-button="Left" aria-label="Left">Left</button>
            <div class="spacer"></div>
            <button type="button" class="control-btn right" data-button="Right" aria-label="Right">Right</button>
            <button type="button" class="control-btn down" data-button="Down" aria-label="Down">Down</button>
          </div>
          <div class="action-buttons">
            <div class="ab-buttons">
              <button type="button" class="control-btn" data-button="B" aria-label="B button">B</button>
              <button type="button" class="control-btn" data-button="A" aria-label="A button">A</button>
            </div>
            <div class="meta-buttons">
              <button type="button" class="control-btn small-btn" data-button="Select" aria-label="Select">Select</button>
              <button type="button" class="control-btn small-btn" data-button="Start" aria-label="Start">Start</button>
            </div>
          </div>
        </div>
        <div class="footer-text">
          <div class="keyboard-legend" id="legend">
            <p>Controls: Arrow Keys (D-Pad) | a=A | s=B | j=Start | k=Select</p>
          </div>
          <div>
            <p>
              This is an independent, open-source Game Boy emulator.
              Not affiliated with or endorsed by Nintendo.
              Game Boy is a trademark of Nintendo Co., Ltd.
            </p>
            <p>
              This site does not host or distribute game ROMs or firmware.
              Users must provide their own legally obtained copies.
            </p>
          </div>
        </div>
      </div>
    </footer>
    <script>
      const FPS = 60;
      const CYCLES_PER_FRAME = 70224; // GB cycles per frame

      function bindOnScreenControls(memoryManagementUnit) {
        const buttonElements = document.querySelectorAll("[data-button]");
        const setButtonState = (button, pressed) => {
          if (memoryManagementUnit?.joypad?.buttons?.hasOwnProperty(button)) {
            memoryManagementUnit.joypad.buttons[button] = pressed;
          }
        };

        buttonElements.forEach((element) => {
          const buttonName = element.dataset.button;

          const press = (event) => {
            event.preventDefault();
            element.setPointerCapture?.(event.pointerId);
            setButtonState(buttonName, true);
          };

          const release = (event) => {
            event.preventDefault();
            setButtonState(buttonName, false);
            if (element.hasPointerCapture?.(event.pointerId)) {
              element.releasePointerCapture(event.pointerId);
            }
          };

          element.addEventListener("pointerdown", press);
          element.addEventListener("pointerup", release);
          element.addEventListener("pointercancel", release);
          element.addEventListener("pointerleave", release);
          element.addEventListener("pointerout", release);
        });
      }

      async function main() {
        const canvas = document.getElementById("screen");
        const romInput = document.getElementById("rom-input");
        const romButton = document.getElementById("rom-button");
        const romFilenameLabel = document.getElementById("rom-filename");
        const saveStateButton = document.getElementById("save-state");
        const loadStateButton = document.getElementById("load-state");
        const stateInput = document.getElementById("state-input");
        const saveGameButton = document.getElementById("save-game");
        const loadGameButton = document.getElementById("load-game");
        const saveInput = document.getElementById("save-input");

        const memoryManagementUnit = new MemoryManagementUnit();
        const cpu = new Cpu(memoryManagementUnit);
        const pixelProcessingUnit = new PixelProcessingUnit(canvas, memoryManagementUnit);
        const audioProcessingUnit = new AudioProcessingUnit(memoryManagementUnit);
        memoryManagementUnit.apu = audioProcessingUnit;

        let romReady = false;
        let animationHandle = null;
        let currentRomName = "";
        let batterySaveTimer = null;

        const scheduleBatterySave = () => {
          if (!memoryManagementUnit.hasBatteryBackedStorage()) return;
          if (batterySaveTimer) return;
          batterySaveTimer = setTimeout(() => {
            batterySaveTimer = null;
            memoryManagementUnit.saveBatteryRam();
          }, 1000);
        };

        const flushBatterySave = () => {
          if (batterySaveTimer) {
            clearTimeout(batterySaveTimer);
            batterySaveTimer = null;
          }
          memoryManagementUnit.saveBatteryRam(true);
        };

        memoryManagementUnit.onExternalRamWrite = scheduleBatterySave;
        window.addEventListener("beforeunload", () => {
          flushBatterySave();
        });

        const setRomLabel = (name) => {
          if (romFilenameLabel) {
            romFilenameLabel.textContent = name || "";
            romFilenameLabel.title = name || "";
          }
        };

        const pad = (value) => String(value).padStart(2, "0");

        const encodeBytes = (u8) => {
          if (!u8) return null;
          let binary = "";
          const chunk = 0x4000;
          for (let i = 0; i < u8.length; i += chunk) {
            binary += String.fromCharCode.apply(null, u8.subarray(i, i + chunk));
          }
          return btoa(binary);
        };

        const decodeBytes = (str) => {
          if (!str) return null;
          const binary = atob(str);
          const out = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            out[i] = binary.charCodeAt(i);
          }
          return out;
        };

        const toUint8 = (source, fallbackLength = 0) => {
          if (!source && source !== 0) {
            return fallbackLength ? new Uint8Array(fallbackLength) : null;
          }
          if (typeof source === "string") return decodeBytes(source);
          if (source instanceof Uint8Array) return source;
          if (source instanceof ArrayBuffer) return new Uint8Array(source);
          if (Array.isArray(source)) return new Uint8Array(source);
          return fallbackLength ? new Uint8Array(fallbackLength) : null;
        };

        const formatStateFilename = () => {
          const base = currentRomName ? currentRomName.replace(/\.[^/.]+$/, "") : "state";
          const safeBase = (base.replace(/[^a-zA-Z0-9_-]+/g, "") || "state").toLowerCase();
          const now = new Date();
          return `${safeBase}_${now.getFullYear()}_${pad(now.getMonth() + 1)}_${pad(now.getDate())}_${pad(now.getHours())}_${pad(now.getMinutes())}_${pad(now.getSeconds())}.state`;
        };

        const formatSaveFilename = () => {
          const base = currentRomName ? currentRomName.replace(/\.[^/.]+$/, "") : "save";
          const safeBase = (base.replace(/[^a-zA-Z0-9_-]+/g, "") || "save").toLowerCase();
          return `${safeBase}.sav`;
        };

        const startLoopIfNeeded = () => {
          if (!animationHandle) {
            animationHandle = requestAnimationFrame(frame);
          }
        };

        const loadRomFromFile = async (file) => {
          if (!file) return;
          flushBatterySave();
          const buffer = await file.arrayBuffer();
          romReady = false;
          await memoryManagementUnit.loadROM(buffer);
          memoryManagementUnit.loadBatteryRam();
          cpu.reset();
          pixelProcessingUnit.reset();
          audioProcessingUnit.reset();
          romReady = true;
          currentRomName = file.name;
          setRomLabel(currentRomName);
          startLoopIfNeeded();
        };

        const createSnapshot = () => {
          return {
            version: 1,
            romName: currentRomName,
            timestamp: Date.now(),
            cpu: cpu.getState(),
            mmu: memoryManagementUnit.getState(),
            ppu: pixelProcessingUnit.getState(),
            apu: audioProcessingUnit.getState(),
          };
        };

        const downloadState = () => {
          if (!romReady) {
            console.warn("No ROM loaded; cannot save state.");
            return;
          }
          const snapshot = createSnapshot();
          const blob = new Blob([JSON.stringify(snapshot)], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = formatStateFilename();
          a.style.display = "none";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        };

        const downloadSaveGame = () => {
          if (!romReady) {
            console.warn("No ROM loaded; cannot export save.");
            return;
          }
          if (!memoryManagementUnit.hasExternalRam()) {
            console.warn("This cartridge has no external RAM to export.");
            return;
          }
          const data = memoryManagementUnit.getBatteryRamBytes();
          if (!data) {
            console.warn("No save data available to export.");
            return;
          }
          const blob = new Blob([data], { type: "application/octet-stream" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = formatSaveFilename();
          a.style.display = "none";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        };

        const loadSaveFromFile = async (file) => {
          if (!file) return;
          if (!romReady) {
            console.warn("No ROM loaded; cannot load save.");
            return;
          }
          if (!memoryManagementUnit.hasExternalRam()) {
            console.warn("This cartridge has no external RAM to load.");
            return;
          }
          const buffer = await file.arrayBuffer();
          const ok = memoryManagementUnit.setBatteryRamBytes(new Uint8Array(buffer));
          if (!ok) {
            console.warn("Failed to apply save data.");
            return;
          }
          memoryManagementUnit.saveBatteryRam(true);
        };

        const loadStateFromFile = async (file) => {
          if (!file) return;
          try {
            const text = await file.text();
            const snapshot = JSON.parse(text);
            romReady = false;
            if (snapshot.mmu) {
              memoryManagementUnit.setState(snapshot.mmu);
            }
            if (snapshot.cpu) {
              cpu.setState(snapshot.cpu);
            }
            if (snapshot.ppu) {
              pixelProcessingUnit.setState(snapshot.ppu);
            }
            if (snapshot.apu) {
              audioProcessingUnit.setState(snapshot.apu);
            }
            currentRomName = snapshot.romName || currentRomName || "state";
            setRomLabel(currentRomName);
            romReady = !!memoryManagementUnit.rom;
          } catch (err) {
            console.error("Failed to load state", err);
          } finally {
            startLoopIfNeeded();
          }
        };

        if (romButton && romInput) {
          romButton.addEventListener("click", () => romInput.click());
          romInput.addEventListener("change", (event) => {
            const file = event.target.files?.[0];
            if (file) {
              loadRomFromFile(file).catch(console.error);
            }
            event.target.value = "";
          });
        }

        if (saveStateButton) {
          saveStateButton.addEventListener("click", () => {
            downloadState();
          });
        }

        if (saveGameButton) {
          saveGameButton.addEventListener("click", () => {
            downloadSaveGame();
          });
        }

        if (loadStateButton && stateInput) {
          loadStateButton.addEventListener("click", () => stateInput.click());
          stateInput.addEventListener("change", (event) => {
            const file = event.target.files?.[0];
            if (file) {
              loadStateFromFile(file).catch(console.error);
            }
            event.target.value = "";
          });
        }

        if (loadGameButton && saveInput) {
          loadGameButton.addEventListener("click", () => saveInput.click());
          saveInput.addEventListener("change", (event) => {
            const file = event.target.files?.[0];
            if (file) {
              loadSaveFromFile(file).catch(console.error);
            }
            event.target.value = "";
          });
        }

        window.addEventListener("keydown", (e) => {
            switch (e.key) {
                case "a": memoryManagementUnit.joypad.buttons.A = true; break;
                case "s": memoryManagementUnit.joypad.buttons.B = true; break;
                case "k": memoryManagementUnit.joypad.buttons.Select = true; break;
                case "j": memoryManagementUnit.joypad.buttons.Start = true; break;
                case "ArrowUp": memoryManagementUnit.joypad.buttons.Up = true; break;
                case "ArrowDown": memoryManagementUnit.joypad.buttons.Down = true; break;
                case "ArrowLeft": memoryManagementUnit.joypad.buttons.Left = true; break;
                case "ArrowRight": memoryManagementUnit.joypad.buttons.Right = true; break;
            }
        });

        window.addEventListener("keyup", (e) => {
            switch (e.key) {
                case "a": memoryManagementUnit.joypad.buttons.A = false; break;
                case "s": memoryManagementUnit.joypad.buttons.B = false; break;
                case "k": memoryManagementUnit.joypad.buttons.Select = false; break;
                case "j": memoryManagementUnit.joypad.buttons.Start = false; break;
                case "ArrowUp": memoryManagementUnit.joypad.buttons.Up = false; break;
                case "ArrowDown": memoryManagementUnit.joypad.buttons.Down = false; break;
                case "ArrowLeft": memoryManagementUnit.joypad.buttons.Left = false; break;
                case "ArrowRight": memoryManagementUnit.joypad.buttons.Right = false; break;
            }
        });

        bindOnScreenControls(memoryManagementUnit);

        function frame() {
          if (!romReady) {
            animationHandle = requestAnimationFrame(frame);
            return;
          }

          let cyclesThisFrame = 0;

          while (cyclesThisFrame < CYCLES_PER_FRAME) {
              memoryManagementUnit.joypad.update();
              const cycles = cpu.executeStep(); // returns cycles used
              memoryManagementUnit.step(cycles);
              pixelProcessingUnit.step(cycles);
              audioProcessingUnit.step(cycles);
              cyclesThisFrame += cycles;
          }

          animationHandle = requestAnimationFrame(frame); // schedule next frame
        }

        startLoopIfNeeded();
      }
      main();
    </script>
  </body>
</html>
